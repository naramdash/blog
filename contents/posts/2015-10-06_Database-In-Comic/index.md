---
public: true
category: "Post"
date: "2015-10-06T14:35:00+09:00"
title: "[만화로 쉽게 배우는 데이터베이스] 정리"
description: "`만화로 쉽게 배우는 데이터베이스`에 대한 내용 정리"
primaryImage:
  source: ../../images/Book-Review.jpg
  alt: "Book Review"
tags:
  - "Book Review"
  - "Database"
---

**이 글은 2015년 10월에 네이버 블로그에 작성한 내용을 옮겨온 것입니다.**

```toc

```

![책 표지](https://bookthumb-phinf.pstatic.net/cover/053/249/05324913.jpg?udate=20130113)
[만화로 쉽게 배우는 데이터베이스](https://book.naver.com/bookdb/book_detail.nhn?bid=5324913)

## 1장 데이터베이스의 필요성

### 독자적 데이터 관리의 단점

- 데이터들이 중복되어 있음
- 데이터 간의 불일치가 발생될 가능성이 생김
- 새로운 변화에 대처하기 어려움

### 데이터를 잘 활용하기 위한 방법

- 간단하게 데이터의 입력과 출력을 할 수 있는 방법이 있어야 함(모든 사람이 쉽게 다룰 수 있어야함)
- 안전성의 확보
- 데이터베이스의 변경 등의 문제를 일관성 있게 처리
- 데이터가 분실되지 않도록 주의 + 장애에 대비할 필요
- 데이터 검색속도가 빨라야함

### DBMS(database management system, 데이터베이스 관리 시스템)

## 2장 데이터베이스의 기본 용어

### 레코드(record)

파일 중에 하나의 단위로 취급되는 관련된 데이터

### 필드(field)

레코드 속의 각 항목

### 유일성(unique)를 가진다

상품 코드와 같이 값이 중복되지 않는 것을 데이터베이스에서 이르는 말

### NULL값

값이 비어있는 것. NULL값이 있으면 안되는 필드도 있음.

### 데이터 모델(data model)

데이터들 간에 어떤 관계를 띄고 있는지, 그 데이터를 어떻게 조작할 것인지 모델화 한 것

### 계층형 데이터 모델(hierarchical data model)

데이터들끼리 나무처럼 계층 관계를 이루는 데이터 모델

하위데이터들이 하나의 상위데이터를 가짐

### 그물형 데이터 모델(network data model)

데이터들끼리 망사형 관계를 이루는 데이터 모델

하위데이터가 여러 상위 데이터를 가질 수 있음

이러한 모델은 데이터가 포인터(pointer)라고 부르는 장치에 의해 서로 연결되며 데이터들의 관계를 나타냄. 포인터란 데이터를 디스크 상의 어느 위치에 저장했는지 나타내는 장치. 위 두 모델은 포인터를 사용함으로써 데이터의 물리적 위치 구조를 의식하면서 사용해야함. 이 때문에 유연하고 빠른 데이터 검색이 어려움.

### 관계형 데이터 모델(relational data model)

2차원 표(table)을 기본으로 하는 데이터 모델

표를 관계(relation)라고도 부름. 수학 연산을 기본으로 데이터 조작. 엄밀히 정의된 연산을 반복하면 데이터들을 표로써 나타낼 수 있는 것.

### 행(行, row)

하나의 단위로 취급되는 관련된 데이터, 즉 레코드

### 열(列, column)

각 데이터 항목, 즉 필드

### 키(key)

데이터베이스에서 중요한 역할을 부여받은 필드

### 기본 키(primary key, 주 키)

데이터를 식별하는 중요한 역할을 하는 필드

### 합집합(union)

두 개의 표에 포함된 행을 전부 출력하는 연산

### 차집합(difference)

한쪽의 표에만 속하는 행을 출력하는 연산

둘 중에 어느 표를 기준으로 하느냐에 따라서 결과가 달라짐

### 교집합(intersection)

표 모두에 공통적으로 존재하는 행을 출력하는 연산

### 곱집합(cartesian production)

2개의 표의 행의 조합을 전부 편성하여 출력하는 방법

2개의 표의 행들을 조합하여 만든 모든 경우의 수

일반 집합 연산자

합집합, 차집합, 교집합, 곱집합 총 4가지

### 프로젝션(projection)

표 안의 특정 열을 출력해 내는 연산

### 셀렉션(selection)

표 안의 행을 뽑아내는 연산

### 조인(join)

표를 연결해 이어지는 작업

외래 키(foreign key)가 다른 표의 기본 키(primary key, 주 키)를 참조할 때 조인을 사용해 2개의 표를 서로 이어줌

### 디비전(division)

나뉨을 당하는 표에서 나누는 역할을 하는 표의 행을 포함하는 모든 행을 추출해 낸 후 추출한 행에서 나누는 쪽의 모든 행을 지우는 연산

## 3장 데이터베이스의 설계 방법

### E-R모델

현실세계를 개체(entity)와 관계(relationship)라는 개념을 사용해서 생각하는 것

### 개체(entity)

현실 세계에서 개채로서 나타낼 수 있는 대상

개체에 주목함으로써 대상을 알기 쉽게 분석할 수 있음

### 관계(relationship)

개체끼리 어떻게 연결되어 있는지 나타냄

개체들이 어떤 식으로 관련되어 있는지 분석함으로써 현실을 정확하게 파악

### 기수성(cardinality)

개체간 대응하는 경우의 수

일대일 관계(one to one): Ex) 하나의 수출처가 하나의 수출 이력 정보를 관리한다.

일대다 관계(one to many): Ex) 한 공주에게 여러 신하가 소속, 신하는 다른 사람에게 소속되지 않는다.

다대다 관계(many to many): Ex) 과일은 여러 개의 수출처로 수출, 수출처는 여러 종류의 과일을 수입

### 정규화(normalization)

데이터끼리 일치하지 않는 경우가 생기지 않도록 표를 나누는 작업

### 비정규형

반복되는 항목들이 배제되지않은 표

### 1차 정규형(first normal form)

표를 이차원의 단순한 표로 만드는 작업

하나의 집단에 하나의 항목이 들어가도록 표를 만듬

### 2차 정규형(second normal form)

데이터를 식별할 수 있는 키를 이용해서 다른 열에 들어있는 값이 정해질 수 있도록 분할하는 것

이 작업은 기본 키에 의해 다른 열의 값이 정해지도록 만들어야 함

2차 정규형은 기본 키에 의해 다른 열이 함수 종속(functional dependant: 특정 열의 값에 의해 다른 열의 값이 정해지는 것) 될 수 있도록 표를 분할하는 것

### 3차 정규형(third normal form)

각 항목의 값이 기본 키 이외의 항목에 의해 결정되지 않도록 분할하는 것

3차 정규형에서는 이행 종속(transitive dependency: 함수 종속 중에서 특정 열의 값에 의해 다른 열의 값이 정해지는 것)을 제거하기 위해 표를 분할

### 개념 스키마(conceptual schema)

현실 세계를 모델화하는 단계

데이터베이스의 논리적인 구조를 결정하는 단계

개념 스키마의 설계는 E-R모델을 이용해 현실세계를 파악하거나 표를 정규화 시킴으로써 행해짐

### 내부 스키마(internal schema)

컴퓨터 내부에서 본 데이터베이스

데이터베이스의 물리적인 구조를 결정하는 단계

내부 스키마의 설계는 데이터베이스의 빠른 검색방법을 설계하는 등의 방법으로 행해짐

### 외부 스키마(external schema)

유저 어플리케이션(user application)의 입장에서 본 데이터베이스

외부 스키마의 설계는 애플리케이션 프로그램을 필요로 하는 데이터를 설계함으로써 행해짐

## 4장 관계형 데이터베이스를 다루는 SQL

### SQL(Structured Query Language)의 기능

데이터 정의어 DDL(Data Definition Language): 데이터베이스의 틀을 작성하는 기능

데이터 조작어 DML(Data Manipulation Language): 데이터베이스 상의 데이터를 조작하는 기능

데이터 제어어 DCL(Data Control Language): 데이터베이스의 제어를 기능. 데이터간의 불일치가 발생하지 않도록 제어

### 문(文)

SQL에서의 1개의 대화

```sql
SELECT 상품명 FROM 상품;
```

### 구(句, phrase)

[SELECT 상품명], [FROM 상품]과 같은 단어의 집합

### FROM 구

빼내고 싶은 표의 이름을 지정

### SELECT 구

빼내고 싶은 열의 이름을 지정

SELECT : 모든 열을 지정

### WHERE 구

조건을 지정

```sql
WHERE 단가 >= 200
```

조건을 사용할 때에는 비교 연산자(comparative operator), 논리 연산자(logical operator)를 사용.

문자를 조건에 사용할 때는 ‘ ’안에 입력

LIKE 기호를 사용하여 패턴과 일치하는 문자열을 검색할 수 있음. 임의의 문자열을 나타내는 %나 하나의 문자를 나타내는 \_을 사용. 이 문자들을 와일드 카드(wild card)라고 부른다.

```sql
WHERE 상품명 LIKE ‘%두’
```

### BETWEEN~AND~ 구

값의 범위를 지정할 수 있음

### ORDER BY 구

검색결과를 정렬하는 방법을 정할 수 있음.

```sql
ORDER BY 단가
```

### 통계 함수

COUNT(): 행의 개수를 구함

COUNT(열의 이름): NULL값을 제외한 행의 개수를 구함

COUNT(DISTINCT 열의 이름): NULL값과 중복된 행을 제외한 행의 개수를 구한다

SUM(열의 이름): 각 행의 합계를 구한다

AVG(열의 이름): 각 행의 평균값을 구한다

MAX(열의 이름): 각 행의 최대값을 구한다

MIN(열의 이름): 각 행의 최소값을 구한다

Ex) 단가 행의 값의 평균을 구하는 문:

```sql
SELECT AVG(단가) FROM 상품;
```

### GROUP BY 구

그룹별로 집계 값을 구할 수도 있음

그룹화시켜 집계낸 값에 대해 한번 더 조건을 지정하여 범위를 좁히고 싶을 경우 WHERE 구를 사용하는 것이 아니라 HAVING 구를 사용한다.

```sql
SELECT 지방, AVG(단가)
FROM 상품
GROUP BY 지방
HAVING AVG(단가) >= 200;
```

### 서브쿼리(subquery)

질의(query, 쿼리)를 하는 도중에도 별도의 질의를 하는 것

```sql
SELECT \*
FROM 상품
WHERE 상품코드 IN
(SELECT 상품코드
FROM 매출명세
WHERE 수량>= 1000); //서브쿼리
```

### 상관관계 서브쿼리(correlated subquery)

서브쿼리의 안쪽은 서브쿼리 밖에서 지정한 표를 사용하는 것

### 조인(Join)

표를 잇는 것. ‘기본 키와 그것을 참조하고 있는 외래 키가 같다’는 조건을 붙여주어야 한다.

이퀴 조인(equi join): 같은 의미를 나타내고 있는 열들을 이용해 표를 조인하는 것. 같은 값을 가지는 행을 조인조건으로 지정하여 표들을 연결.

자연 조인(natural join): 중복하는 열들을 하나로 정리하는 조인. 통상적으로 표를 조인할 때에는 자연 조인을 실행한다.

내부 조인(inner join): 값이 공통적인 행만을 선택하여 합치는 조인 방식.

외부 조인(outer join): 어느 쪽이든 한 쪽의 표에 행 전체를 남기고 여기에 다른 표에 없는 행에 NULL값을 설정하는 조인 방식

2개의 표를 SQL문 중에서 좌, 우로 두었을 때, 어느 쪽 표의 행을 전부 남겼느냐에 따라 좌외부 조인(left outer join)과 우외부 조인(right outer join)으로 나뉜다.

열의 이름은 쉼표(comma)로 잇는다. 같은 열의 이름이 있을 때에는 표의 이름과 열의 이름 사이에 마침표(period)를 써 넣는다.

```sql
SELECT 매출.보고서코드, 일자
매출.수출처코드, 수출자명
매출명세.상품코드, 상품명, 단가, 수량
FROM 매출, 매출명세, 상품, 수출처
WHERE 매출.보고서코드 = 매출명세.보고서코드
AND
매출명세.상품코드 = 상품.상품코드
AND
수출처.수출처코드 = 매출.수출처코드;
```

### CREATE TABLE 구

표를 작성하는 구

```sql
CREATE TABLE 상품
(
상품코드 NUMBER(3,0)
상품명 CHAR(20)
단가 NUMBER(10,0)
PRIMARY KEY(상품코드) //기본 키의 지정
);
```

### 제약(constraint)

미리 제약을 부여해 두면 데이터 간의 불일치를 방지할 수 있음.

PRIMARY KEY: 기본 키를 설정

UNIQUE: 유일성을 설정

NOT NULL: NULL값을 허가하지 않음

CHECK: 범위를 체크함

DEFAULT: 디폴트 값을 설정

FOREIGN KEY/REFERENCE: 외래 키를 설정

### INSERT, DELETE, UPDATE 구

차례대로 추가, 삭제, 갱신문

```sql
INSERT INTO 상품(상품코드, 상품명, 단가) VALUES(101, ‘멜론’, 800);

UPDATE 상품 SET 상품명=’머스크멜론’ WHERE 상품명=’멜론’;

DELETE FROM 상품 WHERE 상품명=’앵두’;
```

### 뷰 테이블(viewed table)

작성한 표를 기반으로 하여 유저(user)들에게 보여질 때에만 존재하는 가상의 표

뷰 테이블과 반대로 실제 데이터가 입력된 표를 베이스 테이블(base table)이라 함.

고액상품이라는 이름의 뷰 테이블을 작성하기 위한 SQL문:

```sql
CREATE VIEW 고액상품(상품코드, 상품명, 단가)
AS SELECT
FROM 상품
WHERE 단가 >= 200;
```

뷰 테이블을 작성한 후에는 뷰 테이블을 베이스 테이블처럼 검색할 수도 있음

```sql
SELECT
FROM 고액상품
WHERE 단가 >=500;
```

베이스 테이블 및 뷰 테이블의 삭제는 다음과 같다

```sql
DROP VIEW 고액상품;

DROP TABLE 상품;
```

### 페치(fetch)

커서(cursor, 행의 위치를 나타냄)를 사용하여 한 행씩 데이터를 출력하는 것

## 5장 데이터베이스 시스템의 구조

### 트랜잭션(transaction)

유저들이 실행하는 의미를 가지는 하나의 그룹으로 묶을 수 있는 작업

### ACID 속성(ACID properties)

트랜잭션에 요구되는 성질

A(Atomicity, 원자성): 트랜잭션은 커미트나 롤백 둘 중의 하나로 종료되어야 한다.

C(Consistency, 일관성): 트랜잭션을 실행할 때, 데이터베이스의 일관성은 손실되지 않는다.

I(Isolation, 격리성): 트랜잭션을 병렬적으로 처리할 경우에도 순차 처리했을 때와 처리 결과는 동일하다.

D(Durability, 영속성): 완료된 트랜잭션의 내용은 장애에 의해서 손실되지 않는다.

### 커미트(commit)

각각의 트랜잭션 작업이 올바르게 끝났을 경우에 데이터베이스에서의 실행처리완료를 뜻함.

관계형 데이터베이스를 다루고 있는 SQL에서는 커미트를 강제적으로 실행하는 COMMIT문이 존재

Ex) COMMIT;

갱신 무효(lost update)의 문제

트랜잭션 작업을 실행하기 전에 데이터베이스들 간에 불일치가 없었을 경우라도, 작업을 실행한 후의 데이터베이스에 불일치가 존재하는 문제

트랜잭션이 병렬적으로 작업을 처리할 때 여러 개의 트랜잭션이 같은 표나 행에 동시에 액세스할 수도 있음. 이 때에 트랜잭션의 처리 순서에 따라 불일치가 생겨날 가능성이 있을 수 있음.

### 직렬 가능(serializable)

여러 개의 트랜잭션을 병렬처리해도 이것이 순차 처리했을 때와 같은 결과가 될 때에 이것을 직렬 가능이라고 부름

### 락(lock)

필요한 데이터가 잘못되지 않도록 잠금하는 것

### 공유 락(shared lock)

공유 락이 걸려있는 데이터는 다른 유저들이 데이터를 볼 수는 있지만 입력할 수는 없음

공유 락이 걸려있을 때에는 다른 트랜잭션은 공유 락은 걸 수 있지만 배타 락은 걸 수 없음

### 배타 락(exclusive lock)

배타 락이 걸려있는 데이터는 다른 유저들이 데이터를 출력할 수도, 입력할 수도 없음

배타 락이 걸려있을 때에는 다른 트랜잭션은 공유 락도, 배타 락도 걸 수 없음

### 병행 제어(concurrency control)

락을 사용해서 복수의 트랜잭션을 제어하는 것

병행 제어를 함으로써 가능한 한 많은 사람들이 이용하면서도 데이터간의 불일치가 일어나지 않도록 함

### 2단계 락킹(two-phase locking)

트랜잭션 처리의 직렬가능성을 보장하기 위해 존재하는 락의 설정과 해제에 대한 일정한 규약 중 하나

각 트랜잭션은 락을 거는 단계와 락을 해제하는 단계로 구성되어 있음

2단계 락킹에서는 한번에 락을 걸고, 한번에 락을 해제한다

### 차단 범위(granularity)

락을 거는 범위

차단 범위를 크게 하면 각각의 트랜잭션이 락을 거는 횟수가 줄어들어 CPU의 부담이 줌. 하지만 락의 대상범위가 넓기 때문에 다른 트랜잭션에 걸린 락의 해제를 기다리는 시간이 길어짐. 이 때문에 동시에 실행할 수 있는 트랜잭션의 수는 감소하게 됨.

반대로 차단 범위를 작게 하면 각각의 트랜잭션이 락을 거는 횟수가 늘어 CPU 부담이 늚. 그러나 락의 대상범위가 좁기 때문에 다른 트랜잭션에 걸린 락의 해제를 기다리는 시간이 줄어듬. 이 때문에 동시에 실행할 수 있는 트랜잭션의 수는 증가하게 됨.

### 롤백(rollback)

트랜잭션을 취소하는 것

트랜잭션 도중에 어떤 문제가 발생해 작업을 완료할 수 없는 경우에는 커미트가 아닌 롤백을 실행

트랜잭션은 반드시 커미트 혹은 롤백 둘 중의 하나로 종료

관계형 데이터베이스를 다루고 있는 SQL에서는 롤백을 강제적으로 실행하는 ROLLBACK문이 존재

Ex) ROLLBACK;

### 시간기록기 제어(timestamp control)

트랜잭션이 액세스하는 데이터에 타임스탬프(timestamp)라고 불리는 기록을 부여

어떤 트랜잭션이 그 데이터를 입s출력하려고 할 때, 그 트랜잭션보다도 새로운 타임스탬프를 가지는 트랜잭션이 데이터를 갱신한 경우에는 데이터의 입s출력을 허가하지 않는 방법

입s출력을 허가하지 않는 방법으로 트랜잭션의 롤백을 사용한다.

### 낙관적 제어(optimistic control)

우선 각 트랜잭션의 입s출력을 모두 허가한 후에 처리하는 방법

입력하는 지점을 시작으로 다른 트랜잭션에 의한 데이터가 갱신되지 않았는지의 여부를 검사

다른 트랜잭션에 의해 갱신되었을 경우에는 롤백을 실행한다

### 격리 수준(isolation level)

실제 데이터베이스에서는 동시에 실행 가능한 트랜잭션을 늘리기 위해서 트랜잭션들이 서로 간섭 가능한 레벨을 지정할 수 있도록 설계되어 있음

SQL에서는 SET TRANSACTION문에 의해 이하의 트랜잭션의 격리 수준을 지정할 수 있음

Ex) SET TRANSACTION ISOLATED LEVEL READ UNCOMMITTED;

READ UNCOMMITTED: 오손 판독 발생할 가능성 있음, 반복 불가능 읽기 발생할 가능성 있음, 유령 읽기 발생할 가능성 있음

READ COMMITTED: 오손 판독 발생하지 않음, 반복 불가능 읽기 발생할 가능성 있음, 유령 읽기 발생할 가능성 있음

REPEATABLE READ: 오손 판독 발생하지 않음, 반복 불가능 읽기 발생하지 않음, 유령 읽기 발생할 가능성 있음

SERIALIZABLE: 오손 판독 발생하지 않음, 반복 불가능 읽기 발생하지 않음, 유령 읽기 발생하지 않음

격리 수준을 지정하지 않는 경우에는 SERIALIZABLE이 자동으로 지정된다

### 오손 판독(dirty read)

트랜잭션1의 커미트가 실행되기 전에 트랜잭션2가 그 행을 출력해, 트랜잭션1이 롤백을 실행했을 경우 트랜잭션2가 존재하지 않는 행을 출력하는 현상

### 반복 불가능 읽기(non-repeatable read)

트랜잭션1이 행을 출력했을 때 트랜잭션2가 그 행을 갱신한 후 커미트를 실행하면 트랜잭션1이 그 행을 다시 한번 출력했을 때에 다른 값이 되는 현상

### 유령 읽기(phantom read)

트랜잭션1이 검색을 실행해서, 여러 행의 결과를 얻은 경우에 트랜잭션2가 그 조건에 맞는 행을 추가해서 트랜잭션1의 2번째 검색결과가 달라지는 현상

### 데이터베이스의 보안

데이터베이스는 중요한 데이터를 관리하기 때문에 보안을 확보하는 일이 매우 중요함

보안의 확보는 유저별로 마음대로 데이터를 변경해 데이터들이 불일치를 일으키는 것을 방지하기 위해서도 중요함

데이터베이스에서는 데이터베이스나 표에 액세스 가능한 권한을 설정하는 것이 가능

### GRANT 문

관계형 데이터베이스에서는 SQL문의 하나로써 유저에게 작업 권한을 부여함

GRANT 문에 의해 관리자나 유저들이 작성한 표의 작업 권한을 다른 유저들에게 부여할 수 있음

권한을 설정하는 것은 데이터베이스를 운용하는 데 중요한 작업

Ex) GRANT SELECT, UPDATE ON 상품 TO 외국부;

권한의 예시

SELECT: 표 안의 행을 검색할 수 있는 권한

INSERT: 표 안의 행을 삽입할 수 있는 권한

UPDATE: 표 안의 행을 갱신할 수 있는 권한

DELETE: 표 안의 행을 삭제할 수 있는 권한

ALL: 모든 것이 가능한 권한

데이터베이스 제품에 따라서는 여러 개의 권한을 하나의 그룹으로 만들어 한꺼번에 부여할 수도 있음. 그룹화를 실행하면 권한의 관리가 용이함.

### WITH GRANT OPTION 문

이 문을 이용하여 권한을 부여하면 권한을 부여받은 유저는 다른 유저에게도 권한을 부여할 수 있게 됨

Ex) GRANT SELECT, UPDATE ON 상품 TO 외국부 WITH GRANT OPTION;

### REVOKE 문

GRANT 문으로부터 부여된 권한을 철회할 수 있음

Ex) REVOKE SELECT, UPDATE ON 상품 FROM 외국부;

### 인덱스(index)

데이터의 저장되어 있는 위치에 고속으로 액세스하기 위한 수단

데이터를 검색할 때 모든 행을 검색하면 시간이 많이 걸리기 때문에 인덱스를 만듦

인덱스를 사용하면 디스크에 액세스하는 횟수를 줄여 고속화 함

인덱스의 방법으로서는 B-트리나 해시 등의 방법이 쓰임

통상의 데이터베이스에선 데이터베이스 관리자의 판단으로 인덱스를 지정해서 붙일 수 있음

오히려 너무 많은 인덱스를 만들게 되면 효율이 떨어질 수 있음

### B-트리(B tree)

격납 장소에 관한 정보를 나무 구조로 관리하는 방식

B-트리에서는 노드(node; 절점, 접속점)가 다수의 하위 데이터를 가져 나무의 높이를 파악할 수 있음

이 때문에 많은 데이터들이 존재해도 뿌리부분에서 고속으로 저장 장소에 도달할 수 있게 되어 있음

B-트리에서는 뿌리 이외의 노드를 가질 수 있는 하위 데이터의 최대수를 2n이라고 하면 최소수는 n이 된다

### 해시(hash)

데이터의 키 값에 대해 해싱 함수(hashing function)라 불리는 연산을 적용해서 저장 위치를 구하는 방법

완전 일치 검색에 대해 돋보이지만 패턴 매칭과 같은 애매한 검색에는 대응하지 못한다

### 쿼리를 최적화

일반적인 쿼리의 순서 결정기준

셀렉션을 먼저 실행하면 행수가 줄어든다

프로젝션을 먼저 실행해서 결과와 관계없는 열을 줄인다

조인은 맨 나중에 실행한다

조인을 실행하는 ​방법들

네스티드 루프(nested loop) 조인
한쪽의 표의 1행에 대해 다른 한쪽의 표를 비교해 가는 방법

소트 머지(sort merge) 조인
각 표의 행을 열거해 놓은 후 조인하는 방법. 소트되어 있어서 한 방향 처리로 끝나기 때문에 처리시간이 짧아진다. 단, 최초의 소트에 걸리는 코스트에 주의할 필요가 있다.

해시(hash) 조인
일반적인 표를 해싱 함수에 의해 분할한 후 다른 한쪽의 표에서 같은 해시 값을 가지는 행을 조인하는 방법. 조인하는 행을 효율적으로 뽑아낸다.

### 옵티마이저(optimizer)

데이터베이스 중에서 쿼리의 최적화를 담당하는 기능

최적화의 기준들

룰 베이스(rule based)
미리 여러 개의 룰을 정해두고 룰에 맞게 정해진 우선순위에 따라 수단을 선택하는 방식

코스트 베이스(cost based)
데이터베이스의 내부에 있는 통계 정보에 따라 수단을 선택하는 방식

### 데이터베이스의 복구

장애 상황의 분류

트랜잭션 장애
트랜잭션의 오류에 의해 트랜잭션을 완료할 수 없는 것. 트랜잭션 장애에서는 장애가 발생한 트랜잭션은 롤백이 된다.

시스템 장애
정전 등에 의해 시스템이 다운된 경우를 말함. 시스템 장애 때에는 재가동 후에 장애회복처리를 실행한다. 통상, 장애 발생시 커미트해두지 않은 트랜잭션에 대해서는 롤백을 실행하고 장애 발생시 커미트가 완료된 트랜잭션에 대한 롤 포워드를 실행하는 방식이 쓰임.

미디어 장애
하드디스크가 손상된 경우를 말함. 미디어 장애가 발생한 경우에는 백업 파일을 바탕으로 장애 복구를 실행하게 됨. 백업 이후에 커미트된 트랜잭션에 대해 롤 포워드 처리를 실행한다.

데이터베이스 내부에는 데이터를 조작할 때마다 로그(log)라고 불리는 기록을 하고 있음

특히 중요한 것은 데이터베이스를 갱신할 때 갱신 전후를 기록하는 것

시스템에 장애가 발생한 경우에는 우선 시스템을 재가동, 그리고 로그를 이용하여 데이터베이스를 복구

복구 방법은 트랜잭션이 커미트되어 있는가 아닌가에 따라 달라짐

장애가 생겼을 때 커미트되어 있지 않다면 롤백을 실행. 롤백에서는 갱신 전의 값을 참조하여 트랜잭션 처리를 취소하여 트랜잭션을 시작하기 전의 상태로 되돌리는 것.

### 롤 포워드(roll forward)

장애가 생겼을 때 트랜잭션이 커미트되어 있다면 데이터를 갱신했을 당시의 갱신 후의 값을 참조해서 복구하는 것

### 체크포인트와 복구

실제 데이터베이스에서는 입력을 효율적으로 하기 위해서 일시적으로 버퍼라고 불리는 영역에 데이터를 입력하는 방식이 많이 채택

버퍼에 입력된 내용들은 체크포인트(checkpoint, 검사점)라고 불리는 지점에서 데이터베이스의 내용과 일치됨

이 방식을 채택할 때, 반영 시점에서 커미트가 된 트랜잭션에 대해서는 장애 회복을 실행할 필요가 없음

반영 시점에서 커미트가 되지 않은 트랜잭션은 장애 회복의 대상으로 여겨짐

## 6장 데이터베이스의 응용

웹 시스템에서는 통신프로토콜로서 HTTP(hyper text transfer protocol)가 사용된다. 웹 서버 상에 동작하는 서버 소프트웨어가 유저들의 요구에 응답한다. 유저들에게서 요청(HTTP request)이 있으면 이것을 해석해서 이에 대응하는 웹 페이지를 보여준다(HTTP response).

웹 페이지는 HTML형식의 텍스트 파일로 구성되어 있다. 웹 페이지에서는 동영상 등의 각종 파일이 URL(Uniform Response Locator)로 지정되어 저장된다. 저장된 파일이 있는 경우에는 지정된 URL에 액세스해서 HTTP 요청s응답이 이루어지며 통신을 실행한다.

### 3층 클라이언트s서버 시스템

프레젠테이션 계층
유저들의 입력을 받아들인다. 데이터베이스에 대한 검색조건 등이 입력되는 것. 검색결과의 표시, 처리를 실행. 보통은 웹 브라우저가 프레젠테이션 기능을 담당.

펑션 계층
데이터를 가공. 이 층에서는 SQL문이 구성되는데 만들어진 SQL문의 처리는 각종 프로그래밍 언어 등으로 기술되고 있다. 처리내용s부하에 의해 애플리케이션 서버, 웹 서버 등의 여러 개의 서버로 역할이 분담되어 구성되는 경우도 있다.

데이터 계층
데이터베이스 서버에 의한 처리가 이루어짐. 데이터베이스 서버에서는 데이터베이스가 가동되고 있다. SQL 등으로 인한 각종 질의에 응해 데이터베이스에서 검색결과를 되돌린다.

3층 클라이언트 서버형을 구성하고 있는 것들로 인해 유연하고 간결한 시스템 구축이 가능해짐

예를 들면, 애플리케이션의 기능에 추가s수정이 많을 경우, 펑션 계층을 이용해 시스템을 분리해두면 작업이 용이해진다. 또, 프레젠테이션 계층은 웹 브라우저를 이용하기 때문에 유저들이 작성하는 프로그램을 다시 작성, 인스톨할 필요가 없다.

### 스토어드 프로그​램의 이용

데이터베이스에서는 스토어드 프로그램 등의 기능을 이용해 데이터베이스 서버에 미리 쿼리 등을 프로그램으로서 배치하는 것이 가능.

스토어드 프로그램은 데이터베이스 서버 측에 프로그램이 배치되기 때문에, SQL의 쿼리를 빈번하게 보낼 필요가 없어져 네트워크의 부하를 줄일 수 있음

또한, 정형적(定刑的)인 처리를 기술해 둠으로써 애플리케이션의 개발도 용이해 짐

스토어드 프로그램의 종류

스토어드 프로시져: 처리 순서를 거꾸로 되돌릴 수 없는 프로그램

스토어드 펑션: 처리 순서를 거꾸로 되돌릴 수 있는 프로그램

트리거: 데이터베이스에 작업을 실행하는 전후에 가동되는 프로그램

### 분산 데이터베이스(distributed database)

데이터베이스 자체를 전혀 다른 환경으로 분산시키는 경우. 분산시킨 위치에 존재하는 데이터베이스와 네트워크로 구성됨. 단 분산 데이터베이스에서는 분산되어 있어도 하나의 데이터베이스로서 하나의 장소에 존재하는 것처럼 다루어야 함.

무관성(transparency)

유저들이 데이터의 위치나 이동을 신경 쓰지 않고 분산 데이터베이스를 이용할 수 있는 성질

### 수평 분산

여러 개의 대등한 데이터베이스 서버를 사용하는 방법

각각의 데이터베이스 서버는 다른 데이터베이스 서버의 데이터를 이용할 수 있다. 또, 반대로 다른 데이터베이스 서버에서 자신이 가지고 있는 데이터를 이용할 수도 있다. 이러한 형태는 부서별로 가동 중인 데이터베이스를 확장한 시스템 등으로 사용되고 있다.

어느 하나의 서버에 장애가 일어나도 데이터베이스는 가동될 수 있으므로 장애에 강한 시스템이라고 할 수 있다.

### 수직 분산

데이터베이스 서버에 각각 다른 기능을 가지게 하는 방법

중심적인 역할을 하는 주 서버와 처리를 의뢰하는 각각의 서버로 구분. 각 서버들이 주 서버의 데이터베이스를 이용할 수는 있지만 주 서버가 각 서버의 데이터를 이용할 수는 없다. 때문에 수직 분산에서는 주 서버의 관리가 쉬운 반면 주 서버에 통신이 집중되는 것. 전체 조직인 주 서버와 각 부서 개별 서버로 구성하는 경우 등에 쓰이고 있다.

### 수평 분할

행 방향 분할

분할된 행은 각 서버에 분산시켜 배치. 같은 종류의 데이터를 지역별로 관리하고자 할 경우에 이러한 형태를 채택한다.

### 수직 분할

열 방향으로 분할하는 것

분할된 열은 각 서버에 분산 배치된다. 독립된 부서별로 데이터베이스를 분산 데이터베이스로서 관리하고자 할 경우에 이러한 형태가 채택됨.

### 2단계 커미트(two-phase commit)

분산 데이터베이스에서 불일치가 생기는 것을 방지하기 위한 방법 중 하나

커미트를 제1단계, 제2단계로 나누어 구성하는 방법

2단계 커미트는 조정자(coordinator)와 참가자(participant)로 나누어 짐

2단계 커미트의 제1단계에서는 조정자가 각 참가자에 대해서 커미트가 가능한지 어떤지를 질의한다. 참가자는 커미트가 가능하면 OK대답을 실행한다. 이 준비작업을 시큐어(secure)라고 부른다.

제2단계에서는 조정자가 커미트의 지시를 따라 참가자에 의한 커미트를 실행한다.

2단계 커미트에서는 제1단계에서 어느 하나의 장소에서라도 시큐어에 실패했을 경우 모든 참가자에게 롤백 지시를 내리게 된다. 때문에 각 서버들의 데이터베이스를 불일치 없이 저장하는 구조가 되는 것.

### 분산 데이터베이스를 이용한 조인

네스티드 루프 조인(nested loop join)
서버A의 표의 1행을 서버B에 송신해 서버B의 표의 모든 행과 비교해 조인을 실행한다. 이것을 서버A의 모든 행에 반복한다.

소트 머지 조인(sort merge join)
각 서버의 표를 미리 소트해 두는 방법. 서버A의 표, 서버B의 표를 각각 소트해둔다. 그 후 서버A의 표를 서버B에 송신한다. 표가 사전에 소트되어 있기 때문에 한 방향으로 읽어내며 조인을 실행한다.

세미 조인(semi join)
조인과 관련 있는 열만을 조인 연산의 대상으로 삼아 서버로 송신해, 행을 추려낸 후에 조인을 실행하는 방법. 우선, 서버A의 상품코드 열을 서버B에 송신한다. 그 다음 서버B가 대응하는 상품코드를 추출한다. 추출한 행은 서버A에 돌려보내진다. 이로 인해 조인 연산이 실행되는 것이다. 행을 추려내기 위해 네트워크의 통신량을 줄여야 하는 경우도 생긴다.

해시 세미 조인(hash semi join)
서버A가 열들에 대한 해시 값을 구해 서버B에 송신하면 서버B에서도 해시 값을 구한다. 각각의 해시 값을 대조함으로써 조인 연산을 실행한다.

### 레플리케이션(replication, 복제)

분산 데이터베이스에서 네트워크의 부하를 줄이기 위해 데이터베이스를 복제하는 경우. 데이터의 복제를 중복해서 가져, 네트워크를 오고가는 데이터를 줄이는 것.

주(主)가 되는 데이터베이스를 마스터 데이터베이스, 복제된 데이터를 레플리카(replica)라고 함.

### 레플리케이션의 종류

출력 전용
주 서버인 마스터 데이터베이스에서 출력 전용의 레플리카를 작성해 이것을 다운로드하는 방법. 레플리카는 주 서버 접속 시에 작성됨. 복제한 데이터는 출력만 가능하도록 되어있음.

주 서버를 갱신 가능
주 서버에서 복제한다. 이 레플리카로 갱신 작업도 할 수 있다. 레플리카를 갱신해도 주 서버인 마스터 데이터베이스에 반영된다.

각 서버로 갱신 가능
각 서버끼리 같은 마스터 데이터베이스를 가지는 방법. 각 서버에서 갱신작업을 실행하면 그 외 서버의 데이터베이스에 반영된다.

### XML(extensible markup language)

데이터의 저장 방식. 데이터를 태그로 구분해 나타내는 확장 가능한 마크를 붙인 언어. 태그를 사용해서 데이터에 독자적인 의미를 부여할 수 있기 때문에 검색 시에도 위력을 발휘한다.

엄밀한 문법을 가지며 프로그래밍에 의한 처리가 매우 간편하다. 더욱이 텍스트 파일이기 때문에 편집 작업을 하거나 각기 다른 시스템 간의 통신에도 용이하도록 설계. 이 때문에 데이터베이스를 대체할 데이터 표현수단으로서 사용되는 경우도 있음.

### 객체 중심 데이터베이스(OODB)

관계형 데이터 베이스에서는 문자 데이터를 표의 형식으로 저장. 그러나 특수한 그림 등을 데이터로 다룰 경우에는 관계형 데이터베이스로는 유연성이 결여될 수 있음. 그래서 객체 중심이라고 불리는 개념을 도입한 데이터베이스가 고려. 객체 중심(object oriented)이란 객체라고 불리는 개념으로 대상을 파악하는 방법. 객체란 데이터와 데이터의 작성방법을 하나의 덩어리로 인식하는 것을 말한다. 데이터를 은폐하고 작성하는 방식만을 공개함으로써 객체를 견고한 부품과 같이 다룬다. 이 기능을 캡슐화(encapsulation)라고 한다. 객체 중심 데이터베이스에서는 각각의 객체 별로 식별자를 부가해서 표현한다. 객체는 인스턴스(instance)라고도 불린다. 객체 중심 데이터베이스에서는 객체 안에 객체를 삽입하거나 복합적인 객체를 관리할 수도 있다. 그림과 텍스트를 합친 정보를 객체로서 데이터베이스 그 상태 그대로 저장하는 것도 가능하다. 객체 중심 데이터베이스에 의해 문자 정보를 초월한 복잡한 데이터를 유연하게 관리할 수 있다. 객체 중심에서는 효율적인 개발을 실행하기 위한 개념이 준비되어 있다. 우선 객체의 양신이 되는 개념을 클래스(class)라고 한다. 또, 객체 중심에서는 클래스가 계층 관계를 가질 수도 있다. 상위 클래스의 데이터s기능을 끌어와서 독자적인 기능을 추가한 하위 클래스를 작성하는 것이 가능하다. 이 관계를 계승(inheritance, 상속)이라 한다.
