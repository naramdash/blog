---
public: true
category: "Post"
date: "2015-09-21T14:51:00+09:00"
title: "객체지향적으로 생각하라! 정리"
description: "객체지향에 대해서 쉽고 자세하게 설명한 `객체지향적으로 생각하라`에 대한 후기와 내용 정리"
primaryImage:
  source: ../../images/Book-Review.jpg
  alt: "Book Review"
tags:
  - "Book Review"
  - "Object-Oriented"
---

**이 글은 2015년 9월에 네이버 블로그에 작성한 내용을 옮겨온 것입니다.**

```toc

```

## 후기

![책 표지](https://bookthumb-phinf.pstatic.net/cover/060/145/06014562.jpg?udate=20141122)
[객체지향적으로 생각하라](https://book.naver.com/bookdb/book_detail.nhn?bid=6014562)

의외로 성실하게도 제가 군생활 중후반쯤에는 컴퓨터기술과 관련된 책을 읽어보자 싶어서 원주도서관에 있는 컴퓨터책은 왠만하면 빌려봤었는데 그게 또 의외로 명저들이었습니다. 그중에 하나는 '객체지향적으로 생각하라!'입니다. 다른 책들은 사실 아무것도 모르는 컴공 1학년이 읽기에는 좀 힘든 기반이 필요한 책들이었는데, 이 책은 그런 기반을 제공한다는 느낌이 들었습니다. 일반적으로 컴퓨터관련학과에서는 C언어나 Python, Java 중 하나를 골라서 프로그래밍 수업을 시작할텐데 C언어가 아닌 이상에야 객체 지향 언어라는 점에서 자유롭지 않을 것이고... 하지만 그런 사실을 가르쳐주지 않는다면 "You can write Fortran in Any language"라는 말도 있듯이 도끼로 망치질을 하듯이 코딩하는 사람이 될 수도 있었을 겁니다.

사실 이 책을 읽기전에는 언어 그 자체가 프로그래밍의 전부라고 생각해서 윈빠였던 저는 바로 C#4.0 책(뇌를 자극하는 C#)을 샀으나... 그 당시에 1학년이었던 저는 굉장히 게을르고 무식했기 때문에 페이지를 제대로 넘기지도 않았습니다. 그나마 그 책을 부대에 가져와서 읽었는데 링크? 쿼리? 그 부분에서 멈추었습니다. 자료구조에 대한 선행학습이 진행되어있어야 했는데 자료구조라고는 이산수학에서 머리랑 꼬리랑 어떻게 저떻게 했던것 같기도하고...

그부분에서 막혔다고 해서 그 전 내용이 술술 이해가 간 건 아니었습니다. 일단 메소드 오버라이딩, 선택적 매개변수, 메소드 숨기기, 분할 클래스 등등... 도대체 왜 있는걸까 싶은 것들과 어떨때 써먹어야하는 기능들이 산재해있었습니다. 헷갈리는 거라면 인터페이스와 델리케이트 등...

일단 이 책을 읽으면서 Object-Oriented Language에 대한 전체적인 접근이 이루어지고 나니 인터페이스와 상속에 관한 건 많이 이해가 갔습니다. 아직 이해가 안 갔다면 아마 제가 노력을 안해서 그렇지 않을까 싶네요. 다음 이 게시판에는 제가 읽으면서 정리한 내용들을 타이핑해서 올릴 예정입니다. 제 방식대로 정리했기 때문에 문제집에 있는 핵심요약집 같은 방식보다는 키워드와 그에 관한 설명 위주로 정리했습니다. 할 일도 별로 없으니 최대한 하루에 한개씩 올릴 수 있도록 하겠습니다!!

## 객체지향 개념 소개

### 객체(Object)

데이터와 행위를 모두 가지고 있는 실체(엔티티, Entity)

### OO와 절차의 차이점

OO설계에서 속성과 행위는 단일 객체에 포함↔절차or구조적 설계에서는 속성과 행위가 분리

### 객체(Object)

속성(데이터)을 나타내기 위한 엔티티 + 행위를 나타내는 메서드

일부 구성원, 속성 및 메서드 모두를 다른 객체로부터 숨길 수 있음.

OO프로그램을 구성하는 블록

### 메서드(Method)

데이터에 대한 연산과 기타 작업을 수행하기 위해 사용. 객체의 구성원(속성과 메서드 모두)에 대한 엑세스를 제어.

### 속성(Attribute)

객체 내에 저장된 데이터 → 객체의 상태를 보임

### 행위(Behavior)

객체가 할 수 있는 일 ex) method in OO

Getter과 setter는 실질적으로 속성의 등록정보(Property)

┗데이터 은닉의 개념을 뒷받침: 다른 객체가 직접 다른 객체 내의 데이터를 이용해서는 안 되기 때문에 프로퍼티가 객체 데이터에 대한 제한된 엑서스를 제공. 접근자(Accessor) 메서드와 변경자(Mutator) 메서드라고 불릴 때도 있음.

### 객체와 클래스

간단히 말해, 클래스는 객체의 청사진. 객체의 인스턴스를 만들 때 객체를 구성하는 기초로 클래스를 사용.

관계형 데이터베이스 분야를 예로 들어 설명 → 데이터 베이스 테이블에서 테이블 자체의 정의(필드, 설명, 사용된 데이터 유형)는 클래스(메타데이터), 객체는 테이블의 행(데이터)

클래스는 객체의 템플릿이나 쿠키절단틀과 같은 것으로 생각⇒클래스를 이용해 객체를 만듦.

myClass myObject;

┗이렇듯 이름 자체에서 myClass가 클래스이고, myObject가 객체임을 분명히 나타냄.

객체마다 고유한 속성과 행위가 있음. 클래스는 이 클래스를 사용하며 만드는 모든 객체가 소유하는 속성과 행위를 정의해야 함. 즉, 객체를 만들기 전에 클래스를 설계해야 함.

### 속성(Attribute)

클래스의 데이터는 속성으로 표현. 클래스마다 속성(Attribute)을 정의해야만 속성이 클래스에서 인스턴스(Instance)가 생긴 각 객체의 상태를 저장할 수 있음.

### 메서드(Method)

메서드는 클래스의 필요한 행위를 구현. 클래스에서 인스턴스가 생긴 모든 객체는 클래스가 정의한대로 메서드(Method)를 갖는다. 메서드는 다른 객체에서 호출한 행위(메시지)를 구현하거나 클래스의 기초적인 내부 행위를 제공할 수 있다. 내부 행위는 비공개(Private) 메서드로 다른 객체에서 액세스할 수 없다. 이런 메서드들은 다른 객체가 객체의 속성 값을 검사하거나 변경할 수 있도록 한다. 이것은 OO시스템의 일반적인 기술이다. 모든 경우에 객체 내에 있는 속성에 대한 액세스는 객체 자체가 제어해야 하며, 다른 객체가 직접 속성을 변경해서는 안 된다.

### 메시지(Message)

메시지는 객체간 의사소통 메커니즘이다. 예를 들어 객체A가 객체B의 메서드를 호출 할 때 객체A는 객체B로 메시지를 보낸다. 객체B의 응답은 반환값에 의해 정의된다. 다른 객체는 한 객체의 비공개(Private) 메서드가 아닌 공개(Public) 메서드만 호출할 수 있다.

### 인터페이스(Interface)

우리는 인터페이스가 객체간 의사소통하는 근본적인 방법을 정의한다는 것을 살펴보았다. 클래스를 설계할 때마다 객체를 올바로 인스턴스로 만들고 운영하기 위하여 인터페이스를 지정한다. 객체가 제공하는 행위는 전송된 메시지가 제공된 인터페이스 중 하나를 사용하여 호출하여야 한다. 대부분의 OO언어에서 인터페이스의 일부인 메서드는 공개(Public)로 지정된다.

### 비공개 데이터

데이터은닉이 효과를 발휘하려면 모든 속성이 비공개(Private)로 선언해야 한다. 그래서 속성은 결코 인터페이스의 일부가 될 수 없다. 공개 메서드만 클래스 인터페이스의 일부이다. 속성을 공개(Public)로 선언하는 것은 데이터 은닉의 개념을 위반하는 것이다.

### 구현(Implement)

공개 속성과 메서드만 인터페이스로 간주. 사용자는 구현의 어떤 부분도 볼 수 없어야 하며, 객체와의 상호작용은 인터페이스를 통해서만 이루어짐. 대부분의 경우 감추어져서 인터페이스의 일부가 되지 않아야 하는 메서드가 있음.

### 상속(Inheritance)

OO설계는 코드 재사용을 쉽게 할 뿐만 아니라 클래스를 재구성하고 다양한 클래스의 공통점을 추려내어 전반적인 클래스 설계를 향상시키는 클래스간 관계를 정의, 상속은 이 기능을 제공하는 기본적인 방법.

상속은 한 클래스가 다른 클래스의 속성과 메서드를 상속하도록 한다. 이는 공통적인 속성과 행위를 추상화하여 전혀 새로운 클래스를 만들 수 있게 한다. 상위 클래스 또는 부모 클래스에는 상속의 대상이 되는 클래스에 공통적인 모든 속성과 행위가 포함.

### 추상화(Abstraction)

상속의 장점은 추상화와 정리기술에 있음.

최근 OO언어에서 클래스는 단일 부모 클래스만 가질 수 있지만, 클래스는 여러 자식 클래스를 가질 수 있음. C++과 같은 언어에서는 여러 부모 클래스를 가질 수 있음. 전자를 단일 상속, 후자를 다중 상속이라 한다.

### Is-a 관계(상속Inheritance)

하위(cat, dog) is-a 상위(mammal)

### 다형성(Polymorphism)

문자적으로 여러형태를 의미하는 그리스어

다형성이 상속과 밀접하게 관련되어있지만 객체지향 기술의 가장 강력한 장점 중 하나라고 따로 인용되는 경우도 흔함. 메시지가 객체로 전송될 때 객체는 그 메시지에 응답하도록 정의된 메서드가 있어야만 함. 상속 계층 구조에서 모든 하위 클래스는 상위 클래스에서 인터페이스를 상속함. 그러나 각각 하위 클래스가 구분된 엔터티이기 때문에 각각은 동일한 메시지에 대해 별도의 응답이 필요할 수 있다.

### 재정의(오버라이딩, Overriding)

기본적으로 부모의 구현을 자식의 것으로 교체한다는 의미

예를 들어 Circle, Square, Star라는 세 가지 형태의 배열이 있다고 가정하자. 이 모두를 Shape객체로 취급하고, 각 Shape객체에 Draw메서드를 보내더라도 Circle, Square, Star는 실제 구현을 제공하기 때문에 최종결과는 다르다. 요약하면 각 클래스는 동일한 Draw메서드에 다르게 반응할 수 있으며, 스스로 그린다. 이것이 다형성이 뜻하는 바이다.

메서드가 추상(Abstract)으로 정의되면 하위 클래스는 이 메서드에 대한 구현을 제공할 것을 요구한다.

### 생성자(Constructor)

Circle클래스는 이름이 같은 Circle이라는 메서드를 갖는다. 메서드 이름이 클래스와 같고 반환유형을 제공하지 않을 때, 이것을 생성자라고 부른다. 생성자를 클래스에 대한 입력 포인트로, 여기에서 객체를 구성할 수 있는 것이라고 생각하자. 생성자는 작업을 초기화하고 시작하기 좋은 장소이다.

### 조합(Composition)

객체가 다른 객체를 담고 있다는 생각을 하는 것이 자연스러움. 객체는 흔히 다른 객체로 구성 또는 조합된다. 이것이 조합(Composition)이다. 상속과 마찬가지로 조합은 객체를 구성하기 위한 메커니즘을 제공한다.

다른 클래스로부터 클래스를 만드는 데에는 상속과 조합, 2가지 방법이 있음.

### Has-a 관계(조합Composition)

Car Has-a engine

## 객체 관점에서 생각하는 방법

이 장에서는 OO사고 과정을 잘 이해하기 위해 할 수 있는 세가지 중요한 일을 다룸.

1. 인터페이스와 구현간에 차이가 있음을 인식
2. 보다 추상적으로 생각
3. 사용자에게 가능한 최소한의 인터페이스만 제공

### 인터페이스와 구현간에 차이가 있다는 점을 인식

클래스를 설계할 때 사용자가 알아야 하는 내용과 알 필요가 없는 내용이 결정적으로 중요. 캡슐화에 내재된 데이터 은닉 메커니즘은 사용자에게 꼭 필요하지 않은 데이터를 숨기는 방법.

인터페이스의 개념을 그래픽 사용자 인터페이스(GUI)와 헷갈리지 말 것.

구현의 변경은 운전자에게 아무런 영향이 없어야 하고, 인터페이스의 변경은 영향이 있을 수 있음. 또한 운전자가 알아차릴 수 있는 구현의 변경은 실질적으로 인터페이스를 변경하게 됨.

올바르게 설계된 클래스는 인터페이스와 구현이라는 두 부분으로 설계됨.

### 인터페이스

최종 사용자에게 제시된 서비스는 인터페이스를 구성한다.
제1원칙으로서 클래스에 대한 인터페이스는 사용자가 알 필요가 있는 내용만 포함 해야 한다.
클래스를 설계할 때 가장 중요하게 고려해야 하는 것은 클래스의 청중 또는 사용자를 식별하는 것.

### 구현

구현의 자세한 내용은 사용자에게 숨겨짐.

구현의 목표: 구현이 변경된다고 해서 반드시 사용자 코드가 변경되어야 하는 것은 아니라는 점 ★설계 문제의 핵심

인터페이스가 제대로 설계될 경우 구현을 변경하더라도 사용자 코드를 변경할 필요가 없음.(인터페이스에는 메서드를 호출하고 값을 반환하기 위한 구문이 포함됨을 기억)

인터페이스가 변경되지 않으면 사용자는 구현이 변경되는지 상관하지 않음.

### 최소 인터페이스

최소한만 추구하는 인터페이스인지 확인할 수 있는 방법

→사용자에게 공개 인터페이스를 전혀 제공하지 않는 것.

→사용자가 기능이 필요하다고 말할 때(요청할 때) 인터페이스를 추가.

### 객체 지속성

객체의 상태를 저장하여 나중에 복구하여 사용할 수 있게 하는 개념.

지속되지 않는 객체는 범위를 벗어날 때 기본적으로 소멸.

### 코드 재컴파일

동적으로 로드되는 클래스는 실행 파일에 정적으로 링크되는 것이 아니라 런타임에 로드됨. 동적으로 로드되는 클래스를 사용할 때 Java와 .Net이 그런 것처럼 어떤 사용자 클래스도 재컴파일할 필요가 없다. 그러나 C++같이 정적으로 링크된 언어에서는 새로운 클래스를 불러오는 링크가 필요하다.

### 인터페이스를 설계할 대 추상적으로 생각하기

일반적으로 재사용 가능한 클래스는 구체적이기보다는 추상적인 인터페이스를 갖는 경향이 있음.

### 사용자에게 최소한의 인터페이스를 제공

클래스를 설계할 때 가장 중요한 규칙은 항상 사용자에게 클래스 내부 동작에 대해서 가능한 적은 정보를 제공하는 것.

★사용자에게 절대적으로 필요한 것만 제공

→클래스가 인터페이스를 가능하면 적게 가진다는 의미

★공개 인터페이스는 사용자가 액세스할 수 있는 것을 정의

→처음에 인터페이스를 비공개로 하여 사용자에게 전체 클래스를 감추면 프로그래머가 클래스를 사용하기 시작할 때 특정 메서드를 공개로 바꾸어야만 하며, 그러면 이런 메서드는 공개 인터페이스가 됨.

★정보시스템 관점이 아니라 사용자 관점에서 클래스를 설계하는 것이 매우 중요

★클래스를 설계할 때 요구사항을 점검하고, 개발자가 아니라 실제로 클래스를 사용할 사람들과 함께 설계해야 함

→클래스는 계속 발전해갈 것이며, 시스템 원형이 구축되고 나서 업데이트해야 할 가능성이 매우 높음

### 객체 행위

모든 사용자 관점에서 각 객체의 목적과 제대로 수행하기 위해 무슨 일을 해야 하는지 확인해야 함.

### 환경적 제약

환경이 객체가 할 수 있는 일에 제한을 둠. 대부분이 변수. 컴퓨터 하드웨어가 소프트웨어 기능을 제한.

### 구현 확인

공개 인터페이스를 선정하고 난 후에는 구현을 확인해야 함.

모든 필요한 메서드를 갖추고 난 다음, 클래스가 작동하도록 하는 구체적인 방법을 고려해야 함.

★기술적으로 공개 인터페이스가 아닌 모든 것은 구현

→사용자가 구현의 일부로 간주되는 메서드와 메서드 서명과 아울러 메서드 내부에 있는 실제 코드를 결코 볼 수 없다는 의미임. 클래스가 내부적으로 사용하는 비공개 메서드가 있을 수 있음. 비공개 메서드는 사용자가 볼 수 없고 액세스할 수 없다는 사실을 고려하면 구현의 일부로 간주.

구현은 사용자에게 완전히 감추어진다. 공개 메서드 내에 있는 코드는 사용자가 볼 수 없기 때문에 실제로는 구현의 일부(사용자는 호출 구조만 볼 수 있을 뿐, 내부 코드는 보지 못 함).

이는 이론적으로 구현으로 간주되는 모든 것은 사용자가 클래스와 인터페이스하는 방법에 영향을 주지 않고 변경할 수 있다는 의미(이것은 구현에서 사용자가 기대하는 답을 낸다는 것을 전제로 함).

사용자가 객체를 보는 방법을 나타내는 것이 인터페이스라면 구현은 객체의 실체 핵심 구성재료. 구현은 객체의 상태를 나타내는 코드를 포함.

## 고급 객체 지향 개념

### 생성자

OO언어에서 생성자는 클래스와 동일한 이름을 공유하며, 반환 유형을 갖지 않음. 컴파일러는 메서드 이름이 클래스 이름과 같다는 것을 인식하고 메서드를 생성자로 간주.

★주의: 생성자는 반환 값을 갖지 않는 것에 주의. 반환 값을 제공할 시 컴파일러가 해당 메서드를 생성자로 취급하지 않음.

### 언제 생성자를 호출하는 가?

Cabbie myCabbie = new Cabbie( );

새로운 키워드는 Cabbie클래스의 새 인스턴스를 만들어서 필요한 메모리가 할당. 그런 다음 생성자 자체가 호출되고 인수가 매개 변수 목록에 전달. 생성자는 개발자가 적합한 초기화에 주의할 수 있는 기회를 제공. 그래서 newCabbie코드는 Cabbie객체에 인스턴스를 만들고 생성자인 Cabbie메서드를 호출.

### 생성자 내부에는 무엇이 있는가?

생성자의 가장 중요한 기능 중 하나는 새로운 키워드를 만났을 때 할당된 메모리를 초기화하는 것.

→생성자 내부에 포함된 코드는 새로 생성된 객체를 초기의, 안정적이고, 안전한 상태로 설정해야 된다.

### 속성 초기화

구조적 프로그래밍에서는 초기화할 목적으로 하우스키핑(or초기화)이란 루틴이 자주 사용됨. 속성 초기화는 생성자 내부에서 수행되는 일반적인 기능.

### 기본 생성자

클래스를 작성하고 생성자를 포함시키지 않더라도 클래스는 컴파일되어 사용 가능. 클래스가 분명한 생성자를 제공하지 않을 경우, 기본 생성자를 제공.

⇒생성자를 직접 작성하던지 여부에 관계없이 적어도 하나 이상의 생성자가 항상 존재한다는 것을 이해해야 함.

어떤 경우에는 기본 생성자면 충분할 수 있지만 대부분의 경우 일종의 메모리 초기화를 수행해야함. 상황에 관계없이 적어도 하나의 생성자를 클래스에 포함시키는 것은 좋은 프로그래밍 습관. 클래스에 속성이 있는 경우 항상 초기화하는 것이 좋음.

### 생성자 제공

가장 중요한 규칙은 생성자 내에서 아무런 일을 할 계획이 없더라도 항상 생성자를 제공해야한다는 것. 내부에서 아무 것도 없이 생성자를 제공하고 나중에 추가할 수 있음. 컴파일러에서 제공하는 기본 생성자를 사용하는 것이 기술적으로 잘못된 것은 아니지만 작성된 코드가 어떤 모습인지 정확하게 아는 것이 좋음.

### 다중 생성자 사용

l 대부분의 경우 한가지 이상의 방법으로 객체 생성 가능.

l 이런 상황에 대응하려면 하나 이상의 생성자를 제공해야함.

### 메서드 오버로딩(메서드 중복)

l 오버로딩은 생성자만이 아니라 모든 메서드에 해당.

l 대부분의 OO언어는 메서드 오버로딩을 제공.

오버로딩(Overloading)은 메서드 서명이 매번 다르기만 하면 프로그래머가 계속해서 동일한 메서드 이름을 사용할 수 있게 함. 서명은 메서드 이름과 매개변수 목록으로 구성.

Public string getRecord(int key) //서명 = 메서드 이름(getRecord) + 매개변수 목록(int key)

### 서명

언어에 따라 서명에 반환 유형이 포함될 수도 있고 않을 수도 있다. Java와 C#에서 반환 유형은 서명의 일부가 아니다. 예를 들어 다음 메서드는 반환 유형이 다르더라도 상충된다.

Public void getCab(string cabbieName);

Public int getCab(string cabbieName);

다른 서명을 사용하면 사용한 생성자에 따라 객체를 달리 생성할 수 있다.

### 상위 클래스가 생성되는 방법

상속을 사용할 대 부모 클래스가 어떻게 생성되는 지 알아야만 한다. 상속을 사용할 때 부모에 대한 모든 것을 상속한다는 것을 기억해야한다. 그러므로 부모의 데이터와 행위 모두에 대해 속속들이 알고 있어야한다. 속성의 상속은 매우 분명하다. 그러나 생성자가 어떻게 상속되는 지는 그렇게 분명하지 않다. 새로운 키워드를 만나서 객체가 할당되고 나면 다음 단계가 벌어진다.

1. 생성자 내부에서 가장 먼저 벌어지는 것은 상위 클래스의 생성자가 호출되는 것. 상위 클래스 생성자에 대한 분명한 호출이 없다면 기본 생성자가 자동으로 호출되지만, 바이트코드에서 코드를 볼 수 있다.
2. 그런 다음 객체의 각 클래스 속성이 초기화. 이것들은 클래스의 정의의 일부인 속성이지(인스턴스 변수), 생성자 내부의 속성이나 기타 메서드(로컬 변수)가 아니다.
3. 생성자에 있는 나머지 코드가 실행됨.

### 생성자 설계

l 클래스를 설계할 때 모든 속성을 초기화하는 것은 좋은 습관

l 속성을 초기화하는 데 컴파일러에 의존하지 않아야 함.

생성자를 사용하여 응용프로그램이 안정된 상태에 있는지 확인할 수 있다.

설계하는 동안 모든 속성이 안정적인 상태를 확인한 다음, 생성자에서 안정적인 상태로 설정하는 것이 바람직한 습관이다.

### 오류 처리

문제를 무시한다

┗모든 응용프로그램의 기초적인 지침은 충돌이 생겨서는 안 됨.

문제를 점검하고 응용프로그램을 취소한다.

┗응용프로그램에서 문제가 있다고 알려주는 메시지를 표시할 수 있음. 결코 좋은 선택은 아님. 사용자에게 혼란을 줌.

문제를 점검하고 복구를 시도한다.

┗훨씬 나은 해법이지만 몇가지 잠재적 제한 요인이 있음. 어디에서 가장 먼저 문제가 나타나는 지 찾아내는 것이 항상 쉬운 것은 아니다. 문제를 발견하기까지 상당한 시간이 걸림. 등등… 처음부터 클래스 속에 오류 처리를 포함하여 설계하는 것이 중요.

### 오류 처리 기법의 혼용

오류 처리 방법이 그 특성상 반드시 객체지향적일 필요는 없지만 OO설계에서 적합한 위치를 갖는다. 예외를 던지는 방법은 오버헤드란 관점에서 비용이 많이 들 수 있다. 그래서 예외가 설계상 탁월한 방법이라고 하여도 설계 및 성능 측면에서의 필요에 따라 다른 오류 처리 기술을 고려해볼 수 있음.

### 예외 던지기

대부분의 OO언어는 예외(Exceptions)기능을 제공. 예외란 시스템 내에서 발생하리라고 기대하지 않은 이벤트. Java, C#, C++에서는 예외를 키워드 잡기(Catch)와 던지기(Throw)로 처리한다(특정 블록이 특정 예외를 처리하도록 작성된다는 것). ⇒ 이렇게 하면 어디서 문제가 발생하기 시작하였는지 찾아내기 위해 적합한 지점으로 코드를 헤집어야 하는 문제를 해결해 줌.

```java
try{
//문제가 심각한 코드
} catch(Exception e){
//예외를 처리하기 위한 코드
}
```

try블록 내에 예외를 던지면 catch블록이 그것을 처리. 해당 블록이 실행 중일 때 예외를 던지면 다음과 같은 일이 발생

1. try블록 실행이 종료된다.
2. catch절을 점검하여 규칙을 벗어나는 예외에 대하여 적합한 catch블록이 포함되어 있는지 확인한다.
3. catch절 중 어느 것도 벗어나는 예외를 처리하지 못 할 경우 다음 상위 수준의 try블록에 전달
4. catch절이 일치하면 catch절에 있는 문이 실행된다.
5. try블록을 따라 문의 실행이 재개된다.

### 범위의 개념

단일 클래스에서 여러 객체의 인스턴스를 만들 수 있다. 이런 객체 각각에는 고유의 정체성과 상태를 가짐. 각 객체는 별도로 생성되고 고유한 별도의 메모리를 할당 받음. 그러나 일부 속성과 메서드는 제대로 선언될 경우 동일한 클래스에서 인스턴스가 만들어진 객체 모두가 공유하여서 이런 클래스 속성과 메서드에 대한 메모리를 공유한다(ex. 생성자 메서드).

메서드는 객체의 행위를 나타내며 객체의 상태는 속성이 표현함. 로컬, 객체, 클래스 세가지 유형의 속성이 있음.

### 로컬 속성(Local Attribute)

특정 메서드가 로컬 속성을 소유함.

### 범위(Scope)

속성(및 메서드)은 특정 범위 내에 존재함. Java, C#, C++에서 범위는 중괄호({})로 나타냄. 클래스 자체는 자신의 범위를 갖는다. 클래스의 인스턴스(즉 각 객체)마다 자신의 범위를 갖는다.

### 객체 속성(Object Attribute)

객체마다 동일한 속성에 대해 값이 다를 때.

### 클래스 속성(Class Attribute)

Java, C#, C++에서 속성을 정적(Static)인 상태로 하면 그렇게 할 수 있다.

```java
Public class number{
    Static int count;
    Public method1( ){}
}
```

Count를 정적으로 선언하면 이 속성은 클래스에서 인스턴스가 생성된 모든 객체에 대해서 단일한 메모리 일부를 할당 받는다. 그래서 클래스의 모든 객체는 Count에 대해여 동일한 메모리 위치를 사용한다. 본질적으로 각 클래스는 단일 사본을 가지며 이것은 그 클래스의 모든 객체가 공유한다. 우리가 OO설계에서 살펴본 글로벌 데이터와 아주 비슷하다.

클래스 속성은 유효하게 사용하는 여러가지 방법이 있지만 동기화 문제가 있을 수 있다는 점을 인식해야 함.

### 연산자 오버로딩(Operator Overloading)

일부 OO언어는 연산자 오버로딩을 허용. 연산자의 의미를 변경할 수 있도록 하는 것. Java와 .Net같은 최근의 OO언어는 연산자 오버로딩을 허용하지 않음.

### 다중 상속(Multiple Inheritance)

클래스가 하나 이상의 클래스로부터 상속할 수 있도록 함. 연산자 오버로딩과 유사한 범주. 프로그래머와 컴파일러 작성자 모두에게 시스템을 상당히 복잡하게 만듦. Java와 .Net에서는 안 됨. 이것을 보상하기 위한 인터페이스를 생성하기는 하지만 결론은 전통적인 다중 상속을 허용하지 않는다는 것.

### 행위 및 구현 상속

Java와 .Net 인터페이스는 행위 상속을 위한 메커니즘인 반면 추상 클래스는 구현 상속을 위해 사용됨. 결론은 Java와 .Net 인터페이스는 구현이 아닌 인터페이스를 제공하는 반면 추상 클래스는 인터페이스와 구현 모두를 제공할 수 있다는 것.

### 객체 연산

객체를 복사하고 비교하는 일이 쉽지 않음. 객체에 참조가 들어있기 때문에 유효하게 복사하려면 참조를 따라가야 함.

### 클래스와 참조

복잡한 데이터 구조나 객체가 가진 문제는 참조를 포함하고 있다는 점. 참조의 사본을 만들기만 한다고 해서 데이터 구조나 참조하고 있는 개체를 복사하지는 않음. 같은 맥락에서 객체를 비교할 때 단순히 하나의 포인터를 다른 포인터와 비교하는 것은 참조만 비교하는 것이지 포인터가 가리키는 대상을 비교하는 것이 아님.

### 심층(Deep) 대 표층(Shallow) 사본

심층 사본은 모든 참조를 따르고 모든 참조된 객체에 대한 새로운 사본이 만들어진 경우를 말함. 심층 사본에는 여러 수준이 관련될 수 있음. 여러 객체에 대한 참조를 가진 객체의 경우, 여러 객체는 이어서 더 많은 객체에 대한 참조를 가질 수 있어서 사본 자체가 상당한 오버헤드를 만들 수 있다. 표층 사본(Shallow Copy)은 참조만 복사하고 여러 수준을 따라가지 않는다.

**대부분의 경우 언어에서 객체를 비교하는 기본 메커니즘을 제공. 일반적으로 그런 것처럼 기본 메커니즘에 의존해서는 안 됨. 클래스를 할 때 알고 있는 클래스가 의도한대로 행동할 지 알 수 있도록 클래스 내부에 비교 함수를 제공하는 것을 고려해야함.**

## 클래스 해부

### 클래스의 이름

클래스를 구분하기 위한 이름. 단순히 확인하기 위한 목적을 넘어서 이름은 서술적이어야 함. 클래스가 무슨 일을 할 수 있고, 보다 큰 시스템 내에서 어떻게 상호작용하는 지 정보를 제공하기 때문.

### 주석(Comment)

클래스의 기능을 이해하는 데 필수적.

/_ ~ _/ : 한 행을 넘어갈 수 있으며 주석을 쓸 때마다 잊지 말고 열고 닫는 주석 기호가 쌍을 이루도록 해야함.

// : 이 뒤에 행 마지막까지 모든 주석 내용을 적음. 종료 기호를 사용할 필요는 없지만 한 행으로 제한하고 주석 다음에 실제 코드가 포함되지 않도록 해야함.

### 속성(Attribute)

객체에 대한 정보를 포함

### 생성자

기본생성자

l 기술적
코드에서 생성자를 전혀 제공하지 않을 경우에만 컴파일러가 제공하는 생성자

l 이 책의 정의
인수(Argument)가 없는 생성자

생성자에 있는 속성을 초기화하는 것이 좋음.

### Null의 무의미성

여러 프로그래밍 언어에서 null값은 아무 값도 없는 것을 나타냄. 속성을 무로 설정하는 것은 유용한 프로그래밍 기법. 변수를 null로 하면 값이 제대로 초기화 되었는지 확인할 수 있음.

### 접근자(Accessor)

대부분 다른 객체가 속성에 직접 액세스할 수 없도록 속성을 비공개로 정의함. 한 객체가 다른 객체의 속성을 액세스해야 할 때가 있지만 그렇다고 직접 액세스할 필요는 없음.

클래스는 자신의 속성을 잘 보호해야함. 가장 중요한 이유는 데이터 무결성과 효율적인 디버깅(모든 코드를 변경하지 않고 접근자만 변경하여 수정가능).

또한 보안의 문제, 접근자를 통해 데이터를 액세스하게 되면 암호 확인과 기타 유효성 확인 방법과 같은 메커니즘을 사용할 수 있음. 이렇게 하면 데이터 무결성을 크게 높일 수 있음.

### 객체(Object)

실제로 각 객체에 대한 static이 아닌 메서드마다 물리적인 사본은 존재하지 않는다. 각 객체는 동일한 물리적 코드를 가리킨다. 그러나 개념적인 수준에서 객체가 전적으로 독립적이고 고유한 속성과 메서드를 가진 것으로 생각할 수 있다.

### 정적 속성(Static Attribute)

속성이 정적이면 클래스는 그 속성에 대한 Setter를 제공하며 Setter를 호출하는 어느 객체나 단일 사본을 변경할 수 있다. 그래서 그 속성에 대한 값은 모든 객체에 대해서 변한다.

### 공개 인터페이스 메서드(접근자 메서드)

생성자와 접근자 메서드 모두 공개로 선언하며 공개 인터페이스의 일부이다. 클래스 생성에서 갖는 특별한 중요성 때문에 이것들이 두드러져 보이는 것. 실질적인 작업의 대부분은 다른 메서드에서 제공. 공개 인터페이스는 매우 추상적이고 구현이 보다 구체적인 경향이 있음.

### 비공개 구현 메서드

클래스에 있는 일부 메서드는 다른 클래스에 숨겨져 있음. 비공개로 선언됨. 이런 비공개 메서드는 단지 구현의 일부이고, 공개 인터페이스의 일부가 아니라는 것을 의미. 이런 클래스(메서드)는 클래스 자체 내부에서 호출할 수 있다고 의미 됨. 비공개 메서드는 엄밀하게 구현의 일부이며, 다른 클래스에서 액세스할 수 없음.

## 클래스 설계 지침

OO프로그래밍은 데이터와 행위를 단일 엔터티에 캡슐화하여 완전한 패키지인 클래스를 생성한다는 사상을 지원. 그래서 클래스는 택시(taxicab)와 같은 논리적인 구성 요스를 나타내야 함.

### 현실 세계 시스템 모델링

OO프로그래밍의 목적 중 하나는 사람들이 실제로 생각하는 방식과 유사하게 현실 세계의 시스템을 모델링하는 것. 클래스를 설계하는 것은 객체 지향 방식으로 이런 모델을 만드는 것. 데이터와 행위가 논리적으로 분리된 엔터티로 존재하는 구조적, 탑다운(top-down) 접근 방식을 사용하는 대신 OO접근 방법은 데이터와 행위를 서로 상호작용하는 방식을 모델로 함.

처음 OO 개발로 옮겨올 때 대부분의 사람들은 여전히 구조적인 방식으로 생각하는 경향이 있음. 주된 실수 중 하나는 행위는 가지고 있지만 속성이 없는 클래스를 만드는 것. 사실상 그들은 구조적 모델에서 함수나 서브루틴 집합을 만들고 있는 것. 이것은 캡슐화의 강력한 장점을 전혀 이용하지 않는 것으로 우리의 의도가 아님.

### 공개 인터페이스 확인

이제는 클래스를 설계할 때 공개 인터페이스를 최소로 유지해야하는 것이 가장 중요함. 클래스를 구성하는 목적 전체는 유용하고 간결한 무엇인가를 제공. 설계가 잘 된 객체의 인터페이스는 고객이 이루고자하는 서비스를 설명. 클래스가 사용자에게 유용한 서비스를 제공하지 않는다면 애초에 구성하지 않았어야 함.

### 최소한의 공개 인터페이스

클래스를 가능한 간결하게 할 수 있음. 작업을 올바르게 할 수 있는 정확한 인터페이스를 제공하는 것이 목적.

불완전한 경우: 작업을 완료할 수 없음

제대로 제한되지 않을 경우: 문제가 생겨 디버깅하거나, 시스템 무결성과 보안에 문제

클래스를 생성하는 것은 업무와 관련된 문제, 설계-과정의 모든 단계에서 같이 처음부터 테스트까지 줄곧 사용자가 개입하는 것이 매우 중요. 이럴 경우 클래스 활용과 아울러 적합한 인터페이스가 보장.

코드 사용자는 내부 동작에 대해 알 필요가 없음. 그들은 객체의 인스턴스를 만들고 객체를 사용하는 방법만 알면 됨. 요약하면 그들에게 목표에 도달하는 방법은 알려주지만 자세한 내용은 감추어야 한다.

### 인터페이스 확장

클래스의 공개 인터페이스가 특정 응용프로그램에 대해 부족하더라도 객체 기술은 쉽게 상속이라는 방법으로 이 인터페이스를 확장하고 적응하게 할 수 있음. 요약하면 상속을 고려하여 설계하면 새로운 클래스는 기존 클래스로부터 상속할 수 있으며 확장된 인터페이스를 가진 새로운 클래스를 생성.

### 구현 은닉

공개 인터페이스를 확인하는 것은 클래스의 사용자와 연관되어 있는 설계상의 문제. 구현은 사용자와는 전혀 연관 없어야 함. 사용자에게 영향을 주지 않고서 구현을 변경할 수 있다면 가장 유용한 클래스.

### 견고한 생성자(or 소멸자) 설계

생성자는 객체를 초기의 안정한 상태에 두어야함. 속성 초기화 및 메모리 관리와 같은 문제가 포함. 또한 객체가 기본 상태로 올바로 생성되는지 확인해야 함.

소멸자를 제공하는 언어에서 반드시 소멸자에 적합한 정리(clean-up) 함수가 있어야함. 대부분 이런 정리는 어느 시점 객체가 취득한 시스템 메모리를 릴리즈함. Java와 .Net은 가비지 컬렉션 메커니즘을 통해 자동으로 메모리를 재요청. C++과 같은 언어에서는 개발자가 소멸자 내에 코드를 포함하여 객체가 존재하는 동안 취득한 메모리를 적절하게 비우도록 해야함. 무시할 시 메모리 누수가 발생함.

### 오류 처리를 클래스 속에 설계

클래스 문서 작성 및 주석 사용

협력하기 위한 객체 구성
클래스를 설계할 때 다른 객체가 어떻게 클래스와 상호 작용하는 지 반드시 알고 있어야함

### 재사용을 고려한 설계

객체는 다양한 시스템에서 재사용될 수 있으며 재사용을 고려하여 코드를 작성해야한다. 설계 과정에서 많은 생각이 필요한 곳이다.

### 확장성을 고려하여 설계

### 서술형 이름 사용

누구나 이름을 읽고서 객체가 나타내는 것이 무엇인지 알 수 있어야한다. 서술형 이름을 사용하는 것은 다양한 개발 패러다임을 초월한 좋은 개발 방법이다.

### 이식 불가 코드 추상화

이식 불가 코드(즉, 특정 하드웨어 플랫폼에서만 실행되는 코드)를 사용해야만 하는 시스템을 설계할 경우 클래스로부터 이 코드를 추상화해야한다. 추상화한다는 것은 자신의 클래스 또는 자신의 메서드(재정의 가능한)에 있는 이식 불가 코드를 분리한다는 의미이다. 특정 시스템에 의지하는 코드를 기본 클래스에 포함시키지 않아야 한다.

### 객체 복사 및 비교 방법 제공

### 가능한 작은 범위 유지

가능한 작은 범위를 유지하는 일은 추상화와 구현 은닉과 나란히 간다. 속성과 행위를 가능하면 로컬화한다는 개념이다. 이렇게 하면 클래스의 유지, 테스트, 확장이 훨씬 쉬워진다.

### 클래스가 스스로 책임지게 함

Polymorphism(다형성)

### 유지 보수를 고려하여 설계

유용하고 간결한 클래스를 설계하면 수준 높은 유지 보수를 증진한다. 코드를 관리 가능한 조각들로 정리할 수 밖에 없다. 유지 보수가 더 편하다. 유지 보수를 증진시키는 방법 중 하나는 독립된 코드를 줄이는 것이다(=한 클래스에 변경하는 내용이 다른 클래스에 전혀 영향을 주지 않거나 최소한인 것).

수준 높은 유지 관리를 증진하려면 클래스 간의 연결성을 낮추어야한다.

### 반복 사용

많이 테스트해보라는 의미

인터페이스 테스트

### 객체 지속성 사용

지속성(persistence)은 객체의 상태를 유지한다는 개념. 프로그램을 실행할 때, 객체를 어떤 방식으로 저장하지 않으면 객체는 그냥 소멸하고 다시는 복구할 수 없음. 시스템에서 나중에 이용할 수 있도록 객체의 상태를 저장해야 한다.

플랫 파일 시스템

관계형 데이터베이스

OO 데이터베이스

### 객체 직렬화와 마샬링

객체를 유선을 통해 전송하려면 시스템에서 객체를 분해하고 유선을 통해 전송한 다음 받는 끝에서 재구성해야한다. 이 과정을 객체 직렬화(serializing)라고 한다. 유선을 통해 실제로 객체를 보내는 것을 마샬링(marshaling)이라고 한다.

직렬화와 역직렬화의 주요한 문제점은 동일한 사양을 사용해야 한다는 점이다. 암호화 알고리즘과 비슷하게 한 객체가 문자열을 암호화하면 해독하는 객체에서 동일한 암호화 알고리즘을 사용해야한다.
